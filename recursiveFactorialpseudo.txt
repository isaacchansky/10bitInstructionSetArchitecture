Pseudo code loosely based on the proposed ISA for 
our implementation of the recursive factorial problem 

the registers are defined as followed:
$sp ->  stack pointer
$t1 ->  temp register
$t2 ->  temp register
$t3 ->  temp register
$t4 ->  temp register
$t5 ->  temp register
$t6 ->  temp register
$and ->  AND register
$zero   ->  integer 0
$one    ->  integer 1
$negone ->  integer -1
$four   ->  integer 4
$load   ->  implicit load register
$gtF    ->  go-to register, hardcoded with F: line #
$gtR    ->  go-to register, hardcoded with R: line #
$gtM    ->  go-to register, hardcoded with M: line #
    
    #$sp-$t7 are the registers refered to in the ADD, SHIFT instructions


 '''
 initial recursion setup pseudocode:

 -initialize counter
-A: increment counter
-add looping label address to stack
-beq counter != num A

 '''


 ADD $four $sp       #increment stack pointer by 4
 
 STORE $h            #push $h, the register storing the halt 
                        label/line number onto stack

ADD $num $t1        #'store' the initial parameter 'num' into the 
                        first add register

ADD $zero $t6        #initialize function counter, goes to 'num'

ITER: ADD $one $t6     #increment counter

ADD $four $sp       #increment stack pointer by 4

STORE 1 $UNRAVEL

BEQ $t1 $t6 UNRAVEL:
BEQ $zero $zero ITER:



'''
unravel pseudocode:
workingProduct == 0
functionCounter == 1
C: if workingproduct == functionCounter; END
#multiply by function counter


'''

 

 


UNRAVEL: 
 ADD $one $t2       #initialize the adder-register for multiplying (what we 
                        and with)

 ADD $zero $t4       #initialize counter to one (refers to bit-place) 
                        **issue: Want to have a way to 'set to zero'... 





MULTIPLY: AND $t2 $t1     #stored in $and, if that is 0, end...

#do our comparison, then increment stuff
 
 ADD $one $t4       #increment multiply counter
 
 BEQ $zero $and BIT_STUFF:   #if bit present, multiply    

 SLT $one $t2       #shift adder-register (ex. 0001 -> 0010) 

 BEQ $zero $and MULTIPLY:   #if no bit present, don't do bit stuff

 BEQ $t2 $zero END_LOOP:    #if we have gone through each bit, return iteration

 

 


BIT_STUFF: ADD $t1 $t3      # add t1(num) to t3(working product)
 
 ADD $negone $t4    #decrement multiply counter
 
 BEQ $zero $t4 MULTIPLY    #branch back to start if counter is at 0 (we 
                                finished multiplying)
 BEQ $zero $zero BIT_STUFF  #branch to bitwise loop otherwise





END_LOOP: LOAD 1 $zero       #load what is at the stack pointer (a line # 
                      register, usually UNRAVEL, unless HALT)


 BEQ $zero $zero $load  #branch to whatever line in the load register

 



HALT:   HLT $h


