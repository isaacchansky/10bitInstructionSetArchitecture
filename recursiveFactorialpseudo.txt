Pseudo code loosely based on the proposed ISA for 
our implementation of the recursive factorial problem 

the registers are defined as followed:
$t1     ->  stack pointer
$t2     ->  temp register
$t3     ->  temp register
$t4     ->  temp register
$store  ->  store register
$beq1   ->  beq register
$beq2   ->  beq register
$beq3   ->  beq register
$s1     ->  
$s2     ->  
$s3     ->  
$four   ->  4 
$load   ->  implicit load register
$negone ->  -1
$zero   ->  0
$one    ->  1
    
    *** $sp-$t7 are the registers refered to in the ADD, SHIFT instructions


 '''
 initial recursion setup pseudocode:

 -initialize counter
-A: increment counter
-add looping label address to stack
-beq counter != num A

 '''


 ADD $four $sp       #increment stack pointer by 4
 
 STORE $h            #push $h, the register storing the halt 
                        label/line number onto stack

ADD $num $t1        #'store' the initial parameter 'num' into the 
                        first add register

ADD $zero $t6        #initialize function counter, goes to 'num'

ITER: ADD $one $t6     #increment counter

ADD $four $sp       #increment stack pointer by 4

STORE 1 $UNRAVEL

BEQ $t1 $t6 UNRAVEL:
BEQ $zero $zero ITER:



'''
unravel pseudocode:
workingProduct == 0
functionCounter == 1
C: if workingproduct == functionCounter; END
#multiply by function counter


'''

 

 


UNRAVEL: 
 ADD $one $t2       #initialize the adder-register for multiplying (what we 
                        and with)

 ADD $zero $t4       #initialize counter to one (refers to bit-place) 
                        **issue: Want to have a way to 'set to zero'... 





MULTIPLY: AND $t2 $t1     #stored in $and, if that is 0, end...

#do our comparison, then increment stuff
 
 ADD $one $t4       #increment multiply counter
 
 BEQ $zero $and BIT_STUFF:   #if bit present, multiply    

 SLT $one $t2       #shift adder-register (ex. 0001 -> 0010) 

 BEQ $zero $and MULTIPLY:   #if no bit present, don't do bit stuff

 BEQ $t2 $zero END_LOOP:    #if we have gone through each bit, return iteration

 

 


BIT_STUFF: ADD $t1 $t3      # add t1(num) to t3(working product)
 
 ADD $negone $t4    #decrement multiply counter
 
 BEQ $zero $t4 MULTIPLY    #branch back to start if counter is at 0 (we 
                                finished multiplying)
 BEQ $zero $zero BIT_STUFF  #branch to bitwise loop otherwise





END_LOOP: LOAD 1 $zero       #load what is at the stack pointer (a line # 
                      register, usually UNRAVEL, unless HALT)


 BEQ $zero $zero $load  #branch to whatever line in the load register

 



HALT:   HLT $h





'''
 initial recursion setup pseudocode:

 -initialize counter
-A: increment counter
-add looping label address to stack
-beq counter != num A

 '''


 ADD $four $sp       #increment stack pointer by 4
 
 STORE 1 $h            #push $h, the register storing the halt 
                        label/line number onto stack

G- ADD $num $t2        #'store' the initial parameter 'num' into tempreg

ADD $zero $t3        #initialize function counter, goes to 'num'

ITER: ADD $one $t3     #increment counter

ADD $four $sp       #increment stack pointer by 4

STORE 1 $UNRAVEL
ADD $t2 $store      #add store to t2
BEQ 1 $t6 UNRAVEL:
BEQ $zero $zero ITER:






HALT:   HLT $h