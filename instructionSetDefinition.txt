10-Bit Instruction Set Architecture
CS318

Robert Vail
Thomas Wagner
Adam Straus
Isaac Chansky
==================================

Project Constraints:
   - 10-bit instructions
   - include a To-Be-Defined instruction
   - include a HALT instruction
   - internal storage is 16 bits wide
   - define size of the main memory
   - define how addresses are constructed/calculated
   - memory is half-word addressable
   - loads and stores write exactly 16 bits (half word)
   - Assume single ported memory
       - max of one read or one write per instruction
       - but, may have a 1bit condition register written at same time
   - restrict file size to no more than 16 registers
   - manual loop unrolling is not allowed
   - choose either access memory then compute, or compute then access memory
       - be consistent
   - can do independent instructions in parallel
       - i.e. add, shift, and subtraction which donâ€™t depend on each other
           takes just as long as a single add instruction

Goals:
   - minimize execution time
   - simplify processor hardware design

===================================


ISA definition:

       10-bit instructions

[ 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ]

 [3-bit opcode]  [7-bits to work with]


8 Instructions:
   3-bit opcodes: ADD, LD, STR, BEQ, SLT, AND, HLT, T-B-D.

Add -> 
  ADD [4 bit $register(1-16)] [3 bit reference to $register(1-8)]

       //3 bit register is one of 8 hardcoded 'add registers'



Load -> 
  LD [1 bit condition <memory or stack> ] [6 bit offset from base address]



Store -> 
  STR [1 bit condition <memory or stack >] [6 bit address to store]

       // STR always stores to a set register, which points to a memory address...



Branch if equal -> 
  BEQ [1 bit condition <compare to $zero or $otherSetRegister] [ 1 bits for register to compare to ][5 bits to specify where we are jumping]



Shift left -> 
  SLT [4 bit shift amount] [3 bit $register to shift]



And -> 
  AND [4 bit $register] [3 bit register to add with]

       //the 3 bit register is some variable we are working with. result is stored in a reserved 'and register'



Halt -> 
  HLT []

       //not sure what to put here but we have to have a halt instruction...




#NOTE:
   How I have the arguments set up now is:
   		first the 1 bit conditional (if present), then the 4-bit register (if present), then the 3-bit register(1-8 range) (if present), then the 6-bit address (if present), then the 2-bit goto address (only in BEQ). 
      I don't know if this is what we want, I just happened to write it down that way. 