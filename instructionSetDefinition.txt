10-Bit Instruction Set Architecture
CS318

Robert Vail
Thomas Wagner
Adam Straus
Isaac Chansky
==================================

Project Constraints:
   - 10-bit instructions
   - include a To-Be-Defined instruction
   - include a HALT instruction
   - internal storage is 16 bits wide
   - define size of the main memory
   - define how addresses are constructed/calculated
   - memory is half-word addressable
   - loads and stores write exactly 16 bits (half word)
   - Assume single ported memory
       - max of one read or one write per instruction
       - but, may have a 1bit condition register written at same time
   - restrict file size to no more than 16 registers
   - manual loop unrolling is not allowed
   - choose either access memory then compute, or compute then access memory
       - be consistent
   - can do independent instructions in parallel
       - i.e. add, shift, and subtraction which donâ€™t depend on each other
           takes just as long as a single add instruction

Goals:
   - minimize execution time
   - simplify processor hardware design

===================================


REGISTER FILE:

$t1
$t2
$t3
$t4
$t5
$t6
$beq1
$zero
$beq2
$beq3
$one
$four
$flag
$load
_____
_____


ISA definition:

       10-bit instructions

[ 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ]

 [3-bit opcode]  [7-bits to work with]


ADD [4][3]
LOAD [1][6]  or [1][3][3]
STOR [1][6]
BEQ [1][2][4]
SLL [4][3]
AND [1][3][3]


8 Instructions:
   3-bit opcodes: ADD, LD, STR, BEQ, SLL, AND, HLT, T-B-D.
Add -> 
  ADD [4 bit $register(1-16)] [3 bit reference to $register(1-8)]
       //3 bit register is one of 8 hardcoded 'add registers'

Load -> 
  LD [1 bit condition <memory or stack> ] [6 bit offset from base address]  #from mem
          OR
  LD [1 bit that gets ignored] [3 bit flag(all 1's)][register that holds stack pointer] #from stack

Store -> 
  STR [1 bit condition <memory or stack >] [6 bits to store]

Branch if equal -> 
  BEQ [1 bit condition <compare <$zero or $beq1>] [ 2 bits <compare $zero $beq2 $beq3 $one>][4 bits to specify where we are jumping]

Shift left -> 
  SLT [4 bit shift amount] [3 bit $register to shift]

And -> 
  AND [1 bit flag <'set register' or 'real and'>][3 bit $register pos (1-8)] [3 bit register pos (1-8)]

Halt -> 
  HLT []
       //guess we just have no parameters, it just halts...